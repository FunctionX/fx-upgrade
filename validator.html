<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>f(x)Core validator</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
</head>
<body>
<div class="container-fluid text-center">
    <div class="row">
        <table class="table table-striped table-hover">
            <thead>
            <tr>
                <th scope="col">#</th>
                <th scope="col">Validator</th>
                <th scope="col">Bonded Tokens</th>
                <th scope="col">Status</th>
                <th scope="col">Commission Rates</th>
                <th scope="col">Missed Blocks</th>
            </tr>
            </thead>
            <tbody id="isSign">
            </tbody>
        </table>
    </div>
</div>

<script type="text/javascript">
    const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
    const ALPHABET_MAP = {};
    for (let z = 0; z < ALPHABET.length; z++) {
        const x = ALPHABET.charAt(z);
        ALPHABET_MAP[x] = z;
    }

    function polymodStep(pre) {
        const b = pre >> 25;
        return (((pre & 0x1ffffff) << 5) ^
            (-((b >> 0) & 1) & 0x3b6a57b2) ^
            (-((b >> 1) & 1) & 0x26508e6d) ^
            (-((b >> 2) & 1) & 0x1ea119fa) ^
            (-((b >> 3) & 1) & 0x3d4233dd) ^
            (-((b >> 4) & 1) & 0x2a1462b3));
    }

    function prefixChk(prefix) {
        let chk = 1;
        for (let i = 0; i < prefix.length; ++i) {
            const c = prefix.charCodeAt(i);
            if (c < 33 || c > 126)
                return 'Invalid prefix (' + prefix + ')';
            chk = polymodStep(chk) ^ (c >> 5);
        }
        chk = polymodStep(chk);
        for (let i = 0; i < prefix.length; ++i) {
            const v = prefix.charCodeAt(i);
            chk = polymodStep(chk) ^ (v & 0x1f);
        }
        return chk;
    }

    function convert(data, inBits, outBits, pad) {
        let value = 0;
        let bits = 0;
        const maxV = (1 << outBits) - 1;
        const result = [];
        for (let i = 0; i < data.length; ++i) {
            value = (value << inBits) | data[i];
            bits += inBits;
            while (bits >= outBits) {
                bits -= outBits;
                result.push((value >> bits) & maxV);
            }
        }
        if (pad) {
            if (bits > 0) {
                result.push((value << (outBits - bits)) & maxV);
            }
        } else {
            if (bits >= inBits)
                return 'Excess padding';
            if ((value << (outBits - bits)) & maxV)
                return 'Non-zero padding';
        }
        return result;
    }

    function toWords(bytes) {
        return convert(bytes, 8, 5, true);
    }

    function fromWordsUnsafe(words) {
        const res = convert(words, 5, 8, false);
        if (Array.isArray(res))
            return res;
    }

    function fromWords(words) {
        const res = convert(words, 5, 8, false);
        if (Array.isArray(res))
            return res;
        throw new Error(res);
    }

    function getLibraryFromEncoding(encoding) {
        let ENCODING_CONST;
        if (encoding === 'bech32') {
            ENCODING_CONST = 1;
        } else {
            ENCODING_CONST = 0x2bc830a3;
        }

        function encode(prefix, words, LIMIT) {
            LIMIT = LIMIT || 90;
            if (prefix.length + 7 + words.length > LIMIT)
                throw new TypeError('Exceeds length limit');
            prefix = prefix.toLowerCase();
            // determine chk mod
            let chk = prefixChk(prefix);
            if (typeof chk === 'string')
                throw new Error(chk);
            let result = prefix + '1';
            for (let i = 0; i < words.length; ++i) {
                const x = words[i];
                if (x >> 5 !== 0)
                    throw new Error('Non 5-bit word');
                chk = polymodStep(chk) ^ x;
                result += ALPHABET.charAt(x);
            }
            for (let i = 0; i < 6; ++i) {
                chk = polymodStep(chk);
            }
            chk ^= ENCODING_CONST;
            for (let i = 0; i < 6; ++i) {
                const v = (chk >> ((5 - i) * 5)) & 0x1f;
                result += ALPHABET.charAt(v);
            }
            return result;
        }

        function __decode(str, LIMIT) {
            LIMIT = LIMIT || 90;
            if (str.length < 8)
                return str + ' too short';
            if (str.length > LIMIT)
                return 'Exceeds length limit';
            // don't allow mixed case
            const lowered = str.toLowerCase();
            const uppered = str.toUpperCase();
            if (str !== lowered && str !== uppered)
                return 'Mixed-case string ' + str;
            str = lowered;
            const split = str.lastIndexOf('1');
            if (split === -1)
                return 'No separator character for ' + str;
            if (split === 0)
                return 'Missing prefix for ' + str;
            const prefix = str.slice(0, split);
            const wordChars = str.slice(split + 1);
            if (wordChars.length < 6)
                return 'Data too short';
            let chk = prefixChk(prefix);
            if (typeof chk === 'string')
                return chk;
            const words = [];
            for (let i = 0; i < wordChars.length; ++i) {
                const c = wordChars.charAt(i);
                const v = ALPHABET_MAP[c];
                if (v === undefined)
                    return 'Unknown character ' + c;
                chk = polymodStep(chk) ^ v;
                // not in the checksum?
                if (i + 6 >= wordChars.length)
                    continue;
                words.push(v);
            }
            if (chk !== ENCODING_CONST)
                return 'Invalid checksum for ' + str;
            return {prefix, words};
        }

        function decodeUnsafe(str, LIMIT) {
            const res = __decode(str, LIMIT);
            if (typeof res === 'object')
                return res;
        }

        function decode(str, LIMIT) {
            const res = __decode(str, LIMIT);
            if (typeof res === 'object')
                return res;
            throw new Error(res);
        }

        return {
            decodeUnsafe,
            decode,
            encode,
            toWords,
            fromWordsUnsafe,
            fromWords,
        };
    }
</script>
<script type="text/javascript">
    function toHexString(byteArray) {
        return Array.from(byteArray, function (byte) {
            return ('0' + (byte & 0xFF).toString(16).toUpperCase()).slice(-2);
        }).join('')
    }

    function httpGetJson(theUrl) {
        let xmlHttp = new XMLHttpRequest();
        xmlHttp.open("GET", theUrl, false); // false for synchronous request
        xmlHttp.send(null);
        const response = JSON.parse(xmlHttp.responseText)
        if (response.result) {
            return response.result;
        }
        return response;
    }

    // const fxRestUrl = "http://127.0.0.1:1317";
    const fxRestUrl = "https://fx-rest.functionx.io";
    // const fxRestUrl = "https://testnet-fx-rest.functionx.io";

    // const fxUrl = "http://127.0.0.1:26657";
    const fxUrl = "https://fx-json.functionx.io:26657";

    // const fxUrl = "https://testnet-fx-json.functionx.io:26657";

    function getValidators() {
        const result = httpGetJson(fxRestUrl + "/cosmos/staking/v1beta1/validators")
        return result.validators
    }

    function getSigningInfos() {
        const result = httpGetJson(fxRestUrl + "/cosmos/slashing/v1beta1/signing_infos")
        return result.info
    }

    function getBlockSignatures() {
        const result = httpGetJson(fxUrl + "/block")
        return result.block.last_commit.signatures
    }

    const validators = getValidators()

    const signBody = document.getElementById("isSign")

    function update() {
        const blockSignatures = getBlockSignatures()
        const signInfos = getSigningInfos()
        signBody.innerHTML = ''
        validators.sort((val1, val2) => {
            const a = BigInt(val1.tokens)
            const b = BigInt(val2.tokens)
            if (a > b) {
                return -1;
            }
            if (a < b) {
                return 1;
            }
            return 0;
        }).forEach((validator, index) => {
            const signature = blockSignatures[index]
            let signInfo = signInfos.find((sign) => {
                const address = toHexString(fromWords(getLibraryFromEncoding('bech32').decode(sign.address).words))
                return address === signature?.validator_address
            })
            if (!signInfo && !signature) {
                signInfo = {missed_blocks_counter: 0}
            }
            let color = "text-success"
            if (signInfo?.missed_blocks_counter > 10 && signInfo?.missed_blocks_counter < 100) {
                color = "text-warning"
            } else if (signInfo?.missed_blocks_counter > 100) {
                color = "text-danger"
            }
            if (!signInfo && signature) {
                color = "text-danger"
                signInfo = {missed_blocks_counter: "No signature block"}
            }
            const tokens = Number(BigInt(validator.tokens) / BigInt(1e16))

            let website = validator.description.website
            if (website !== "" && !website.startsWith("http")) {
                website = "https://" + website
            }

            let para = document.createElement('tr');
            para.innerHTML = `
                <th scope="row">${index + 1}</th>
                <td><a target="_blank" href="${website}">${validator.description.moniker}</a></td>
                <td>${(tokens / 100).toLocaleString()} FX</td>
                <td>${validator.status === "BOND_STATUS_BONDED" ? "✅" : "❌"} ${validator.jailed ? "(jailed)" : ""}</td>
                <td>${(validator.commission.commission_rates.rate * 100).toFixed(2)}%</td>
                <td><a target="_blank" href="https://explorer.functionx.io/fxcore/validator/${validator.operator_address}"><span class="${color}">${signInfo?.missed_blocks_counter}</span></a></td>`
            signBody.appendChild(para)
        })
    }

    update()
    window.setInterval(function () {
        update()
    }, 7000);
</script>
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.5/dist/umd/popper.min.js"
        integrity="sha384-Xe+8cL9oJa6tN/veChSP7q+mnSPaj5Bcu9mPX5F5xIGE0DVittaqT5lorf0EI7Vk"
        crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.min.js"
        integrity="sha384-ODmDIVzN+pFdexxHEHFBQH3/9/vQ9uori45z4JjnFsRydbmQbmL5t1tQ0culUzyK"
        crossorigin="anonymous"></script>
</body>
</html>